n
* __init__.py
:PROPERTIES:
:header-args: :tangle __init__.py
:END:
#+begin_src python
from bitvector import BitVector, flip_n_bits
from bitmatrix import BitMatrix

__all__ = ['BitVector', 'BitMatrix', 'flip_n_bits']
#+end_src
* BitVector
:PROPERTIES:
:header-args: :tangle bitvector.py
:END:
** imports, __init__, getters
#+begin_src python 
from random import randint  # for bit-flipping

class BitVector:
    def __init__(self,
                 value_a,
                 size_in_bits_a,
                 msb_top_a=False):
        if isinstance(value_a, list):
            raise NotImplementedError
        elif isinstance(value_a, str):
            if value_a[0] == '0':
                if value_a[1] == 'x':
                    self._value = int(value_a, 16)
                elif value_a[1] == 'b':
                    self._value = int(value_a, 2)
                else:
                    self._value = int(value_a, 16)
            # if string w/out 0x* prefix, assume hex string by default
            else:
                self._value = int(value_a, 16)
        elif isinstance(value_a, int):
            self._value = value_a
        else:
            raise NotImplementedError
    
        self._m = size_in_bits_a
        # self._max_val_d = int("0b" + "1" * self._m, 2)
        self._max_val_d = pow(2, self._m) - 1
        # self._value = self._value % self._max_val_d
        if self._value > self._max_val_d:
            print "value " + str(self._value) + \
                " not representible given " + str(self._m) + " bits"
            raise ValueError

        # just to be safe, should be unnecessary
        self._value = self._value & self._max_val_d
        self._msb_on_top = msb_top_a

    def m(self):
        return self._m
    def value(self):
        return self._value
#+end_src

** __repr__
#+begin_src python  
    def __repr__(self):
        # length_of_output = self._m + 2 # two chars for '0b'
        # format_string = '#0' + str(length_of_output) + 'b'
        output = "0b"
        for index in range(self.m()):
            output = output + str(self[index])
        return output
#+end_src

** __getitem__
#+begin_src python
    def __getitem__(self, i):
        if i > self._m - 1:
            raise ValueError
        # we might want the (self._m - nth) largest bit (vector addressing, 
        #  rather than intuitive bit ordering)
        if self._msb_on_top:
            address = self._m - i - 1
        else:
            address = i
        # print "here"

        mask = 1 << address
        return (self._value & mask) >> address
#+end_src

** operations
#+begin_src python  
    def _assure_dimensions(self, y):
        if y.m() != self.m():
            raise ValueError

    def __add__(self, y):
        self._assure_dimensions(y)
        return BitVector(self._value ^ y._value, 
                         self._m,
                         self._msb_on_top)

    def __sub__(self, y):
        self._assure_dimensions(y)
        return BitVector(self._value ^ y._value,
                         self._m,
                         self._msb_on_top)

    def __mul__(self, y):
        self._assure_dimensions(y)
        val = 0
        for i in range(self.m()):
            val = val + self[i] * y[i]
        val = val % 2
        return val

    def hamming_weight(self):
        weight = 0
        val = self._value
        for i in range(self._m):
            bit = val & 1
            weight = weight + bit
            val = val >> 1
        return weight

def flip_n_bits(bit_vector_a, n_a):
    if not isinstance(bit_vector_a, BitVector):
        raise ValueError
    else:
        value = bit_vector_a.value()
        m = bit_vector_a.m()
        for i in range(n_a):
            address_of_bit_to_flip = randint(0, m - 1)
            value = value ^ pow(2, address_of_bit_to_flip)
        return BitVector(value, m)
        
#+end_src

** example driver
#+begin_src python :tangle examples/bv_main.py
from bits import BitVector, flip_n_bits

if __name__ == "__main__":
    nbits = 10
    bv  = BitVector("100", nbits)
    bv2 = BitVector("ff", nbits)
    add = bv + bv2
    mul = bv * bv2
    print add, mul
    for i in range(nbits):
        print "bit", i, ":", mul[i]
    print add.hamming_weight()
    print bv
    print flip_n_bits(bv, 1)
#+end_src

* BitMatrix
:PROPERTIES:
:header-args: :tangle bitmatrix.py
:END:
** __init__
#+begin_src python 
from bitvector import BitVector
'''
example:
>>> H = BitMatrix([12, 6, 13, 10, 5, 14, 6, 15, 11, 9 , 8 , 4, 2, 1])
>>> H.print_bits()
[1 0 0 1 1 0 1 0 1 1 1 1 0 0 0]
[1 1 0 1 0 1 1 1 1 0 0 0 1 0 0]
[0 1 1 0 1 0 1 1 1 1 0 0 0 1 0]
[0 0 1 1 0 1 0 1 1 1 1 0 0 0 1]

>>> print H * BitVector(27, H.m())
TODO
'''
class BitMatrix:
    def __init__(self,
                 columns_a,
                 m_a=None,
                 msb_top_a=False):

        if m_a is not None:
            self._m = m_a
        else:
            largest_value = max(columns_a)
            self._m = largest_value.bit_length()

        self._msb_on_top = msb_top_a
        self._n = len(columns_a)
        
        # list of column vectors
        #
        if isinstance(columns_a, list):

            # presumably if the first column is an integer, the rest will be as well
            #
            if isinstance(columns_a[0], int):
                self._columns = []
                for column in columns_a:
                    if column < 0:
                        raise ValueError
                    self._columns.insert(len(self._columns),
                                        BitVector(column, 
                                                  self._m,
                                                  self._msb_on_top))
            elif isinstance(columns_a[0], BitVector):
                self._columns = columns_a

        else:
            raise NotImplementedError
    def n(self):
        return self._n
    def m(self):
        return self._m
#+end_src
** __getitem__
#+begin_src python

    # returns a row vector, by 
    def __getitem__(self, i):
        val = 0
        for j in range(self._n):
            bit_at_row_i_column_j = self._columns[j][i]
            if self._msb_on_top:
                power = self._n - j - 1
            else:
                power = j
            val = val + (bit_at_row_i_column_j << power)
        return BitVector(val, self._n, self._msb_on_top)
#+end_src


** __repr__
#+begin_src python
    def __repr__(self):
        values = [str(col._value) for col in self._columns]
        values_string = "["
        for i, val in enumerate(values):
            values_string = values_string + val
            if i == self._n - 1:
                values_string = values_string + "]"
            else:
                values_string = values_string + ", "
        
        return values_string + " (" + str(self._m) + " bits per column)"
#+end_src

** print_bits, column
#+begin_src python  
    def print_bits(self):
        for i in range(self._m):
            row = "["
            for j in range(self._n):
                row = row + str(self[i][j]) 
                # add space between bits, unless
                if j != self._n - 1:
                    row = row + " "
            row = row + "]"
            print row

    def column(self, col_number_a):
        return self._columns[col_number_a]
#+end_src

** operations
#+begin_src python  
    def transpose(self):
        cols = []
        for i in range(self._m):
            cols.insert(len(cols), self[i])
        return BitMatrix(cols, self._n, self._msb_on_top)

    def __add__(self, y):
        pass
    def __sub__(self, y):
        pass
    def __mul__(self, y):
        # print "mul:", self
        if isinstance(y, BitVector):
            val = 0
            for row_number in range(self._m):
                if self._msb_on_top: 
                    row_number = self._m - row_number - 1
                row_product = self[row_number] * y
                val = val + (row_product << row_number)
            return BitVector(val, self._m, self._msb_on_top)
        elif isinstance(y, BitMatrix):
            output_col_list = []
            for col_number in range(y._n):
                output_col_list.insert(len(output_col_list),
                                       self * y.column(col_number))
            return BitMatrix(output_col_list, self._m, self._msb_on_top)
        else:
            raise ValueError
#+end_src

** example driver
#+begin_src python :tangle examples/bm_main.py
from bits import BitMatrix
from bits import BitVector

if __name__ == "__main__":
    cols = [11, 14, 7, 8, 4, 2, 1]
    m = 4 # 3 bits per column
    msb_on_top = True

    C = BitMatrix(cols, m, msb_on_top)
    print "C:"
    C.print_bits()

    x = BitMatrix([3, 13], m, msb_on_top).transpose()
    print "x:", x
    print x, C
    xC = x * C
    print "xC:", xC
    xC.print_bits()

    print "C':"
    C.transpose().print_bits()
#+end_src

